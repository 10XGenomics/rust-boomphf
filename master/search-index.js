var searchIndex = {};
searchIndex["boomphf"] = {"doc":"boomphf - Fast and scalable minimal perfect hashing for massive key sets A Rust implementation of the BBHash method for constructing minimal perfect hash functions, as described in \"Fast and scalable minimal perfect hashing for massive key sets\" https://arxiv.org/abs/1702.03154. The library generates a minimal perfect hash function (MPHF) for a collection of hashable objects. Note: minimal perfect hash functions can only be used with the set of objects used when hash function was created. Hashing a new object will return an arbitrary hash value. If your use case may result in hashing new values, you will need an auxiliary scheme to detect this condition.","items":[[3,"Mphf","boomphf","A minimal perfect hash function over a set of objects of type `T`.",null,null],[0,"hashmap","","HashMap data structures, using MPHFs to encode the position of each key in a dense array.",null,null],[3,"BoomHashMap","boomphf::hashmap","A HashMap data structure where the mapping between keys and values is encoded in a Mphf. This lets us store the keys and values in dense arrays, with ~3 bits/item overhead in the Mphf.",null,null],[3,"BoomIterator","","Iterate over key-value pairs in a BoomHashMap",null,null],[3,"BoomHashMap2","","A HashMap data structure where the mapping between keys and 2 values is encoded in a Mphf. You should usually use `BoomHashMap` with a tuple/struct value type. If the layout overhead of the struct / tuple must be avoided, this variant of is an alternative. This lets us store the keys and values in dense arrays, with ~3 bits/item overhead in the Mphf.",null,null],[3,"Boom2Iterator","","",null,null],[3,"NoKeyBoomHashMap","","A HashMap data structure where the mapping between keys and values is encoded in a Mphf. Keys are not stored - this can greatly improve the memory consumption, but can only be used if you can guarantee that you will only query for keys that were in the original set.  Querying for a new key will return a random value, silently.",null,null],[12,"mphf","","",0,null],[12,"values","","",0,null],[3,"NoKeyBoomHashMap2","","A HashMap data structure where the mapping between keys and values is encoded in a Mphf. Keys are not stored - this can greatly improve the memory consumption, but can only be used if you can guarantee that you will only query for keys that were in the original set.  Querying for a new key will return a random value, silently.",null,null],[12,"mphf","","",1,null],[12,"values","","",1,null],[12,"aux_values","","",1,null],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Create a new hash map from the parallel array `keys` and `values`",2,{"i":[{"n":"vec"},{"n":"vec"}],"o":{"n":"boomhashmap"}}],[11,"get","","Get the value associated with `key`, if available, otherwise return None",2,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"get_key_id","","Get the position in the Mphf of a key, if the key exists.",2,{"i":[{"n":"self"},{"n":"k"}],"o":{"g":["usize"],"n":"option"}}],[11,"len","","Total number of key/value pairs",2,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"get_key","","",2,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"option"}}],[11,"iter","","",2,{"i":[{"n":"self"}],"o":{"n":"boomiterator"}}],[11,"new_parallel","","Create a new hash map from the parallel array `keys` and `values`, using a parallelized method to construct the Mphf.",2,{"i":[{"n":"vec"},{"n":"vec"}],"o":{"n":"boomhashmap"}}],[11,"next","","",3,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"next","","",5,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"new","","Create a new hash map from the parallel arrays `keys` and `values`, and `aux_values`",4,{"i":[{"n":"vec"},{"n":"vec"},{"n":"vec"}],"o":{"n":"boomhashmap2"}}],[11,"get","","",4,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"get_key_id","","",4,{"i":[{"n":"self"},{"n":"k"}],"o":{"g":["usize"],"n":"option"}}],[11,"len","","",4,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"iter","","",4,{"i":[{"n":"self"}],"o":{"n":"boom2iterator"}}],[11,"get_key","","",4,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"option"}}],[11,"new_parallel","","Create a new hash map from the parallel arrays `keys` and `values`, and `aux_values`, using a parallel algorithm to construct the Mphf.",4,{"i":[{"n":"vec"},{"n":"vec"},{"n":"vec"}],"o":{"n":"boomhashmap2"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_parallel","","",0,{"i":[{"n":"vec"},{"n":"vec"}],"o":{"n":"nokeyboomhashmap"}}],[11,"new_with_mphf","","",0,{"i":[{"n":"mphf"},{"n":"vec"}],"o":{"n":"nokeyboomhashmap"}}],[11,"get","","Get the value associated with `key`, if available, otherwise return None",0,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_parallel","","",1,{"i":[{"n":"vec"},{"n":"vec"},{"n":"vec"}],"o":{"n":"nokeyboomhashmap2"}}],[11,"new_with_mphf","","",1,{"i":[{"n":"mphf"},{"n":"vec"},{"n":"vec"}],"o":{"n":"nokeyboomhashmap2"}}],[11,"get","","Get the value associated with `key`, if available, otherwise return None",1,{"i":[{"n":"self"},{"n":"k"}],"o":{"n":"option"}}],[8,"FastIterator","boomphf","Trait for iterators that can skip values efficiently if the client knows they aren't needed.",null,null],[10,"skip_next","","Skip the next item in the iterator, without returning it.",6,{"i":[{"n":"self"}]}],[11,"fmt","","",7,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"heap_size_of_children","","",7,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"new","","Generate a minimal perfect hash function for the set of `objects`. `objects` must not contain any duplicate items. `gamma` controls the tradeoff between the construction-time and run-time speed, and the size of the datastructure representing the hash function. See the paper for details. `max_iters` - None to never stop trying to find a perfect hash (safe if no duplicates).",7,{"i":[{"n":"f64"},{"n":"vec"}],"o":{"n":"mphf"}}],[11,"hash","","Compute the hash value of `item`. This method should only be used with items known to be in construction set. Use `try_hash` if you cannot guarantee that `item` was in the construction set. If `item` was not present in the construction set this function may panic.",7,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"u64"}}],[11,"try_hash","","Compute the hash value of `item`. If `item` was not present in the set of objects used to construct the hash function, the return value will an arbitrary value Some(x), or None.",7,{"i":[{"n":"self"},{"n":"t"}],"o":{"g":["u64"],"n":"option"}}],[11,"new_parallel","","Same as `new`, but parallelizes work on the rayon default Rayon threadpool. Configure the number of threads on that threadpool to control CPU usage.",7,{"i":[{"n":"f64"},{"n":"vec"},{"g":["u64"],"n":"option"}],"o":{"n":"mphf"}}]],"paths":[[3,"NoKeyBoomHashMap"],[3,"NoKeyBoomHashMap2"],[3,"BoomHashMap"],[3,"BoomIterator"],[3,"BoomHashMap2"],[3,"Boom2Iterator"],[8,"FastIterator"],[3,"Mphf"]]};
initSearch(searchIndex);
